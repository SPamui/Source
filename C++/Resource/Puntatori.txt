puntatori e riferimenti

dichiariazine di puntatori : <tipo> *nomeVar

pointer = &var : assegno al puntatore l' indirizzo della variabile

--//dereferenziazione

se a = 5 e pointer = &a
allora cout << *pointer mi da come output 5

se faccio *pointer = 7 cambio il valore di a indirettamente a 7.

puntatore di puntatore : 
int x = 3;
int *p = &x;
int **q = &p

//puntatori nulli

= 0;  = NULL;  =nullptr;

--//puntatore dangling

un puntatore dangling è un puntatore che punta ad una cella
non esistente/non piu valida
es: "
int main(){

    int *y;

    for(int i = 0; i < 2;i++)
    {
        int x = 7;
        y = &x;
        cout << *y << endl;
    }
    
    cout << *y << endl;
    return 0;
}
"
per ovviare a lasciare un puntatore dangling lo assegno a NULL, cosi da
poterlo anche controllare es: "pointer = 0/NULL; if(pointer).. "

--//puntatori e const
//posso dichiarare un puntatore constante

int x;
int *const myPtr = &x;

//es 1

int x, e;
int* const *p1 = &x;
*p1 = e //si, assegno il valore di e alla variabile x
p1 = &e //no, il puntatore essendo costante e' bloccato a puntare alla cella di memoria di x

//2

const int x = 1, e = 2;
const int *p1 = &x;
*p1 = 3 //no, x e' costante
p1 = &e //si, il puntatore non e' costante

//es 3

const int x = 1, e = 2;
const int *const *p1 = &x;
*p1 = e //no, x e' costante
*p1 = &e //no, il puntatore e' bloccato a puntare la cella di x


--//riferimenti
// e' possibile usare alias per le variabili
//es

int x = 2;
int &h = x;

h++; //e' come fare x++
cout << x; //stampera' 3

--//aritmetica dei puntatori
// ha sensosolo se i puntatori si muovo su degli array
//es

int v[100];
int *ptr = &v[0]; //punta al primo elemento dell' array ( e' possibile scriverlo anche int *ptr = v )

cout << *ptr; //uscira' l' elemento all' interno di v[0]
ptr++;
cout << *ptr; //uscira' l' elemento all' interno di v[1]

//per accedere agli elementi potrei anche fare cout << ptr[i];
//essendo il nome di array un puntatore costante posso accedere agli elementi anche cosi: 

int a[3] = {0,1,2};
cout << *(a+2); //uscira' 2

--//stampa di un array

int a[9] = {0,1,2,3,4,5,6,7,8};
int *pinizio = a; //puntatore che punta al primo elemento dell' array
int *pfine = a+9; //puntatore che punta alla cella di memoria dopo l' ultima dell' ultimo elemento dell' array

while(pinizio != pfine)
{
    cout << *pinizio;
    pinizio++;
}

--//tokenizzare una stringa

char testo[80], *p = testo;
cin.getline(testo, 80);

char *parola = strtok(testo, " ,"); //la funzione strtok (cstring) assegna al puntatore parola la sequenza di caratteri terminata da qualsiasi carattere all' interno dei doppi apici, in questo caso ' ', ','
while(parola != nullptr)
{
    cout << parola << endl;       //se la frase = "luca mangia una mela" allora l' output sara' 1-Luca 2-mangia 3-una 4-mela
    parola = strtok(NULL, " ,");
}

--//puntatori e new
i puntatori sono necessari per allocare la memoria in modo dinamico.
con l' operatore 'new' si da una cella di memoria nell' heap
//esempio:
    int *p = new int; //dichiaro un puntatore ad interi 'p' che punta ad un indirizzo di una cella di memoria nell' heap
    int *p = new int(3); //inizializzo l' int dinamico a 3
    //per accedere o modificare il contenuto della cella dinamica si puo normalmente fare uso della deferenziazione
//gli oggetti dinamici non vengono distrutti quando finisce l' ambito di visibilità del quale sono stati creati
//quindi esisteranno finchè non è l' utente a cancellarlo
//da qui il comune errore del Memory leak, cioè cancellare o perdere il collegamento tra puntatore e cella dinamica e quindi perderne //permanentemente l' accesso

